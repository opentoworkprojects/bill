<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billing Cache Performance Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-result { margin: 10px 0; padding: 10px; border-radius: 5px; }
        .success { background-color: #d4edda; color: #155724; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        #results { margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Billing Cache Performance Test</h1>
    <p>This test simulates the billing page loading process to identify performance bottlenecks.</p>
    
    <div>
        <button onclick="testCachePerformance()">Test Cache Performance</button>
        <button onclick="testPreloadingFlow()">Test Preloading Flow</button>
        <button onclick="clearCache()">Clear Cache</button>
    </div>
    
    <div id="results"></div>

    <script>
        const API = 'https://billbytekot.in/api';
        const results = document.getElementById('results');
        
        function addResult(message, type = 'info') {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            results.appendChild(div);
            results.scrollTop = results.scrollHeight;
        }

        // Simple billing cache simulation
        class TestBillingCache {
            constructor() {
                this.cache = new Map();
                this.CACHE_TTL = 300000; // 5 minutes
            }

            getCachedBillingData(orderId) {
                const cached = this.cache.get(orderId);
                if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
                    return cached.data;
                }
                return null;
            }

            async getBillingData(orderId, forceRefresh = false) {
                const startTime = performance.now();
                
                if (!forceRefresh) {
                    const cached = this.getCachedBillingData(orderId);
                    if (cached) {
                        const duration = performance.now() - startTime;
                        addResult(`‚ö° Cache HIT for order ${orderId} - ${duration.toFixed(2)}ms`, 'success');
                        return cached;
                    }
                }

                // Simulate API fetch
                addResult(`üîÑ Fetching fresh data for order ${orderId}...`, 'info');
                const data = await this._fetchBillingData(orderId);
                this._cacheData(orderId, data);
                
                const duration = performance.now() - startTime;
                addResult(`üì° Fresh data fetched for order ${orderId} - ${duration.toFixed(2)}ms`, 'info');
                return data;
            }

            async _fetchBillingData(orderId) {
                const token = localStorage.getItem('token');
                if (!token) {
                    throw new Error('No authentication token found');
                }

                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                };

                try {
                    const [orderRes, businessRes, menuRes] = await Promise.allSettled([
                        fetch(`${API}/orders/${orderId}`, { headers, timeout: 5000 }),
                        fetch(`${API}/business/settings`, { headers, timeout: 5000 }),
                        fetch(`${API}/menu`, { headers, timeout: 5000 })
                    ]);

                    const order = orderRes.status === 'fulfilled' ? await orderRes.value.json() : null;
                    const businessSettings = businessRes.status === 'fulfilled' ? 
                        (await businessRes.value.json()).business_settings : {};
                    const menuItems = menuRes.status === 'fulfilled' ? 
                        (await menuRes.value.json()).filter(item => item.available) : [];

                    if (!order) {
                        throw new Error('Failed to fetch order data');
                    }

                    return { order, businessSettings, menuItems, timestamp: Date.now() };
                } catch (error) {
                    addResult(`‚ùå API Error: ${error.message}`, 'error');
                    throw error;
                }
            }

            _cacheData(orderId, data) {
                this.cache.set(orderId, {
                    data,
                    timestamp: Date.now()
                });
            }

            clearCache() {
                this.cache.clear();
                addResult('üóëÔ∏è Cache cleared', 'info');
            }
        }

        const testCache = new TestBillingCache();

        async function testCachePerformance() {
            addResult('üß™ Starting cache performance test...', 'info');
            
            // Test with a sample order ID (you can change this)
            const testOrderId = '2291b166-75d8-4884-846e-3454ece4ed33';
            
            try {
                // First call - should fetch fresh data
                const start1 = performance.now();
                await testCache.getBillingData(testOrderId, false);
                const duration1 = performance.now() - start1;
                addResult(`üìä First load (fresh): ${duration1.toFixed(2)}ms`, duration1 > 1000 ? 'error' : 'success');
                
                // Second call - should use cache
                const start2 = performance.now();
                await testCache.getBillingData(testOrderId, false);
                const duration2 = performance.now() - start2;
                addResult(`üìä Second load (cached): ${duration2.toFixed(2)}ms`, duration2 > 100 ? 'error' : 'success');
                
                // Performance comparison
                const improvement = ((duration1 - duration2) / duration1 * 100).toFixed(1);
                addResult(`üöÄ Cache performance improvement: ${improvement}%`, 'success');
                
            } catch (error) {
                addResult(`‚ùå Test failed: ${error.message}`, 'error');
            }
        }

        async function testPreloadingFlow() {
            addResult('üß™ Testing preloading flow...', 'info');
            
            const testOrderId = '2291b166-75d8-4884-846e-3454ece4ed33';
            
            try {
                // Clear cache first
                testCache.clearCache();
                
                // Simulate preloading (like OptimizedBillingButton does)
                addResult('üíæ Simulating preload...', 'info');
                const preloadStart = performance.now();
                await testCache.getBillingData(testOrderId, false);
                const preloadDuration = performance.now() - preloadStart;
                addResult(`üíæ Preload completed: ${preloadDuration.toFixed(2)}ms`, 'info');
                
                // Simulate billing page load (should be instant)
                addResult('‚ö° Simulating billing page load...', 'info');
                const loadStart = performance.now();
                await testCache.getBillingData(testOrderId, false);
                const loadDuration = performance.now() - loadStart;
                addResult(`‚ö° Billing page load: ${loadDuration.toFixed(2)}ms`, loadDuration > 100 ? 'error' : 'success');
                
                if (loadDuration > 100) {
                    addResult('‚ùå Billing page should load instantly with preloaded data!', 'error');
                } else {
                    addResult('‚úÖ Billing page loads instantly with preloaded data!', 'success');
                }
                
            } catch (error) {
                addResult(`‚ùå Preloading test failed: ${error.message}`, 'error');
            }
        }

        function clearCache() {
            testCache.clearCache();
            localStorage.removeItem('billbyte_billing_cache');
            addResult('üóëÔ∏è All caches cleared', 'info');
        }

        // Check if user is logged in
        window.addEventListener('load', () => {
            const token = localStorage.getItem('token');
            if (!token) {
                addResult('‚ö†Ô∏è No authentication token found. Please login first.', 'error');
            } else {
                addResult('‚úÖ Authentication token found. Ready to test.', 'success');
            }
        });
    </script>
</body>
</html>